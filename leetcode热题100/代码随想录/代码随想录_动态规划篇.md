[toc]
# 动态规划理论部分:
所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的

对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！

确定dp数组（dp table）以及下标的含义
确定递推公式
dp数组如何初始化
确定遍历顺序
举例推导dp数组




# 509. 斐波那契数
题目中明确给出了dp的递推关系和dp的具体含义:dp[i]第i个斐波那契数列的值
```c++
class Solution {
public:
    int fib(int n) {
        if(n == 0){
            return 0;
        }
        if(n == 1){return 1;}
        vector<int>dp(n,0);

        dp[0] = 1;
        dp[1] = 1;
        for(int i=2;i<n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n-1];
    }
};
```
# 70. 爬楼梯
dp[i] 爬到第i级台阶的时的方法数
dp[i] = dp[i-1] + dp[i-2]; 等于爬一阶 + 爬两阶
```c++
class Solution {
public:
    int climbStairs(int n) {
        vector<int>dp(n+1,0);
        if(n==1){return 1;}
        dp[0] = 1;
        dp[1] = 1;
        for(int i=2;i<n+1;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n]; 
    }
};
```
引申 如果允许一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。
卡码网 57. 爬楼梯（第八期模拟笔试）
```c++
#include<iostream>
#include<vector>
using namespace std;

int main(){
    int m,n;
    cin >> n;
    cin >> m;

    vector<int>dp(n+1,0);
    dp[0] = 1;
    dp[1] = 1;
    for(int i=2;i<n+1;i++){
        for(int k=1;k<=m;k++){
            if(i-k>=0){
                dp[i] += dp[i-k];
            } 
        }
    }
    std::cout << dp[n]<<std::endl;
    return 0;
}
```

这里有一个核心问题:dp[0]为什么要给1 
dp[0]表示站在第0级台阶上的方法数，如果给成0 就需要手动定义dp[2],可以认为到达第0级台阶本身就是一种方法，如果不到第0级台阶，dp[2]就会缺少一种从0级台阶直接走上来的情况


## 377. 组合总和 Ⅳ -- 完全背包 排列问题 -- 爬楼梯
这里如果用二维dp，在更新dp[i][j]的时候，就需要额外用一个循环来遍历所有的组合，这样就会导致复杂度上升


**对于完全背包的排列问题 采用一维 且 先遍历背包 再遍历物品**


<font color=red>严格意义上讲，这个题不是一个背包问题，而是一个爬楼梯问题,题目可以理解为每一次可以往上爬num步，问爬到target层的时候从方案数是多少</font>

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        //dp[i]  凑成正整数为i的排列个数
        vector<int>dp(target+1,0);
        dp[0] = 1;
        for(int i=1;i<target+1;i++){
            for(int num:nums){
                if(i-num >=0 && dp[i]  < INT_MAX -  dp[i-num]){
                    dp[i] += dp[i-num];
                }
            }
        }
        return dp[target];
    }
};
```
## 322. 零钱兑换  --  爬楼梯变种  问最少爬的次数
```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int>dp(amount+1,INT_MAX);
        dp[0] = 0;
        if(amount == 0){return 0;}
        for(int i=1;i<amount+1;++i){
            for(int coin : coins){
                if( i - coin >= 0){
                    dp[i] = min(dp[i],dp[i-coin]);
                }
            }
            dp[i] = dp[i] == INT_MAX ? INT_MAX : dp[i]+1;
        }
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

## 279 完全平方数 -- 爬楼梯变种 当限制步长必须是完全平方数的时候，最小爬的次数
```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int>dp(n+1,INT_MAX);
        dp[0] = 0;
        for(int i = 1;i<n+1;++i){
            for(int j=1;j*j<=i; ++j){
                if( i - j*j >=0 ){
                    dp[i] = min(dp[i],dp[i-j*j]);
                }
            }
           dp[i] += 1; 
        }
        return dp[n];
    }
};
```

# 746. 使用最小花费爬楼梯
dp[i]表示爬到第i级台阶的最小花费
dp[0] dp[1]设置为0 因为可以从第0级和第1级起步，所以起步cost认为是0
```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int>dp(cost.size()+1,0);
        dp[0] = 0;
        dp[1] = 0;
        for(int i=2;i<cost.size()+1;i++){
            dp[i] = min(dp[i-1]+cost[i-1],dp[i-2] + cost[i-2]);
        }
        return dp[cost.size()];
    }
};
```
# 62.不同路径
当前格子的方法数要么是从上一格子向下 要么是从左侧格子向右到达的
```c++
class Solution {
public:
    //dp[i][j] 到i，j位置的方法数
    int uniquePaths(int m, int n) {
        vector<vector<int>>dp(m,vector<int>(n,0));
        dp[0][0] = 1;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0&&j==0){
                    continue;
                }
                if(i==0){
                    dp[i][j] = dp[i][j-1];
                }
                else if(j ==0){
                    dp[i][j] = dp[i-1][j];
                }
                else{
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
};
```
# 63. 不同路径 II
遇到障碍物绕行即可
```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>>dp(m,vector<int>(n,0));
        dp[0][0] = 1;
        if(obstacleGrid[0][0] == 1){return 0;}
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0&&j==0){continue;}
                if(i==0&&obstacleGrid[i][j]!=1){
                    dp[i][j] = dp[i][j-1];
                }
                else if(j==0&&obstacleGrid[i][j]!=1){
                    dp[i][j] = dp[i-1][j];
                }
                else{
                    if(obstacleGrid[i][j]!=1){
                        dp[i][j] = dp[i-1][j] + dp[i][j-1];
                    }
                }
            }
        }
        return dp[m-1][n-1];
    }
};
```
# ***343. 整数拆分
dp[i]表示拆分数字i的最大积，在计算dp[i]的时候，需要从1开始逐步拆分i，这时内层循环存在的原因。
在递推的时候，需要比较的是(i-j)*j （将i拆分成i-j和 j）和 dp[i-j] *j（将i拆分成dp[i-j]的拆分方式和j）两者拆分导致的最大乘积结果
```c++
class Solution {
public:
    //dp[i] 拆分数字i的最大乘积
    int integerBreak(int n) {   
        vector<int>dp(n+1,0);
        dp[1] = 1;
        dp[2] = 1;
        for(int i=3;i<=n;i++){
            for(int j=1;j<i;j++){
                dp[i] = max(dp[i],max(dp[i-j]*j,(i-j)*j));
            }
        }
        return dp[n];
    }
};
```
# *** 96.不同的二叉搜索树
dp[i]节点数量为i的情况下，构成二叉搜索树的数量

外层遍历 就是从2遍历到n 最后返回dp[n]
内层遍历 计算dp[i]   假设现在有i个节点，这i个节点一定是从1递增到i的
可以从1到i，依次选取做二叉树的根节点，如选取j作为当前二叉树的根节点，左侧就有1-j-1一共j-1个节点
右侧有j+1到i一共i-j个节点，此时构成二叉树的方法有dp[j-1]*dp[i-j] 左侧和右侧的组合
最后把1到i分别构成根节点的方法相加即可

举个例子 假设i=3
那么就有 root=1 root=2 root=3三种情况
root=1 （j=1） 左侧有0个节点  *  右侧2个节点
root=2 （j=2） 左侧有1个节点  *  右侧1个节点
root=3 （j=3） 左侧有2个节点  *  右侧0个节点

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int>dp(n+1,0);
        dp[0] = 1;
        dp[1] = 1;
        for(int i=2;i<=n;i++){
            for(int j = 1;j<=i;j++){
                dp[i] += dp[j-1] * dp[i-j];
            }
        }
        return dp[n];
    }
};
```
#  0-1背包理论
对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

递推关系:
不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)
放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值
所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);



**在做背包问题时候，需要明确dp[i][j]的含义是什么，边界dp[0][j] 和 dp[i][0]两个边界，如果无法对边界定义，那么dp迭代就要从0开始，而不是从1开始**

##  卡码网站 46 携带研究材料
小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 
小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。
第二行包含 M 个正整数，代表每种研究材料的所占空间。 
第三行包含 M 个正整数，代表每种研究材料的价值。

6 1
2 2 3 1 5 2
2 3 1 5 4 3
输出 5


dp[i][j]表示0-i区间下 背包容量为j的时候，装value最大值大小
边界条件:
dp[i][0]  当背包容量j=0，自然为0
dp[0][j]  当背包容量j>=weight[0]  dp[0][j] = value[0]


```c++
#include<iostream>
#include<vector>
using namespace std;

int main(){
    int m,n;
    cin >>  m;
    cin >>  n;
    
    vector<vector<int>>weightTovalue(2,vector<int>(m,0));
    for(int i=0;i<2;i++){
        for(int j=0;j<m;j++){
            cin >> weightTovalue[i][j];
        }
    }
    
    //dp[i][j]表示 从下标0-i的物品中取东西，放到大小为j的背包中可以包含的最大的价值
    vector<vector<int>>dp(m,vector<int>(n+1,0));
    //初始化
    for(int i=0;i<m;++i){
        dp[i][0] = 0;
    }
    for(int j=0;j<m;++j){
        if(j>=weightTovalue[0][0]){
            dp[0][j] = weightTovalue[1][0];
        }
    }
    for(int i=1;i<m;++i){
        for(int j=1;j<=n;++j){
            if(j<weightTovalue[0][i]){
                dp[i][j] = dp[i-1][j];
            }
            else{
                dp[i][j] = max(dp[i-1][j],dp[i-1][j-weightTovalue[0][i]] + weightTovalue[1][i]);
            }
        }
    }
    
    cout << dp[m-1][n];
    return 0;
}
```
## 416. 分割等和子集  -- 背包正好装满
方案1 （out time）计算数组总和，如果数组和是偶数，就把问题转换成在数组中查找和为sum/2的情况，对于这个问题用dfs会超时
```c++
class Solution {
public:
    int cal_sum(const vector<int>&nums){
        int left = 0;
        int right = nums.size()-1;
        int sum = 0;
        while(left < right){
            sum += nums[left] + nums[right];
            left ++;
            right --;
        }
        if(left == right){
            sum += nums[left];
        }
        return sum;
    }
    bool dfs(const vector<int>&nums,int target,int start){
        //std::cout << target << std::endl;
        if(target < 0){
            return false;
        }
        if(target == 0){
            return true;
        }
        bool res = false;
        
        for(int i = start ; i < nums.size();i++){
            bool tmp = dfs(nums,target-nums[i],i+1);
            if(tmp){return true;}
            res = res | tmp;
        }
        return res;
    }
    bool canPartition(vector<int>& nums) {
        int sum = cal_sum(nums);
        if(sum%2 != 0){return false;}
        int target = sum / 2;
        return dfs(nums,target,0);
    }
};
```

方案2 ：在数组中查找和为sum/2的情况，使用0-1背包问题，dp[i][j] 0-i的区间内 数组的和是j能否到达
对于边界的说明:
dp[0][nums[0]] = true          0-0区域 就是nums[0] 就是看nums[0]能不能放到背包中
dp[i][0] = true                         0-j区域  选取和为0是一定可以选取的  -- 代表在0-j区域不选取任何一个数字，和自然是0
```c++
class Solution {
public:
    int cal_sum(const vector<int>&nums){
        int left = 0;
        int right = nums.size()-1;
        int sum = 0;
        while(left < right){
            sum += nums[left] + nums[right];
            left ++;
            right --;
        }
        if(left == right){
            sum += nums[left];
        }
        return sum;
    }

    bool canPartition(vector<int>& nums) {
        int sum = cal_sum(nums);
        if(sum%2 != 0){return false;}
        int target = sum / 2;
        vector<vector<bool>>dp(nums.size(),vector<bool>(target+1,false));
        if(nums[0] <= target){
            dp[0][nums[0]] = true;
        }
        for(int i=0;i<nums.size();++i){
            dp[i][0] = true;
        }
        for(int i=1;i<nums.size();++i){
            for(int j=1;j<target+1;++j){
                if(j - nums[i] >= 0 ){
                    dp[i][j] = dp[i-1][j] | dp[i-1][j-nums[i]];
                }
                else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[nums.size()-1][target];
    }
};
```
## 1049.最后一块石头的重量II
这里dp[i][j]表示 0-i的stones区间下，背包空间是j的时候   子数组的和的最大值是多少
初始化说明:
1.dp[i][0]  当背包容量j=0，dp自然是0
2.dp[0][j] 当选取只有nums[0]的时候，dp应当是所有j>=nums[0]的条件下值为nums[0]
```c++
class Solution {
public:
    /*
        对于石头碰撞来说 a和b碰撞 留下的是a-b块石头
        如果再有一块石头c 留下的是c - a + b块石头
        问题转化：在stones数组中  将石头分成两堆，两堆的差值最小
        等价于 在stones中选取子数组和最接近 sum/2
    
    */
    int cal_sum(const vector<int>&stones){
        int left = 0;
        int right = stones.size()-1;
        int sum = 0;
        while(left < right){
            sum += stones[left] + stones[right];
            left++;
            right--;
        }
        if(left == right){
            sum += stones[left];
        }
        return sum;
    }
    int lastStoneWeightII(vector<int>& stones) {
        int sum = cal_sum(stones);
        //由于int除法是向下取整的，如果能整除 就说明石头能全部消除完毕，如果找就留下的是取整的小值
        int target = sum / 2;
        vector<vector<int>>dp(stones.size(),vector<int>(target+1,0));
        for(int j = 1;j<target+1;++j){
            if(j >= stones[0]){
                dp[0][j] = stones[0];
            }
        }
        for(int i=1;i<stones.size();++i){
            for(int j = 1;j<target+1;++j){
                if(j >= stones[i]){
                    dp[i][j] = max(dp[i-1][j] ,  dp[i-1][j-stones[i]] + stones[i]);
                }
                else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return sum - 2* dp[stones.size()-1][target];
    }
};
```
## 494.目标和
dp[i][j]表示在0-i的区域内，构成和为j的方法数
注意这个题目的初始化:
1.dp[0][j]  当j == nums[0]的时候  dp[0][nums[0]] = 1 表示0-0区间内有一种方法能满足nums[0]
2.特别注意的是，如果此时nums[0] = 0,dp[0][0]初值应该赋值为2，+0和-0都是0，表示两种方法
3.dp[i][0] 表示0-i区间内和为0的方法，这个是需要迭代计算的，内层的for循环也是从0开始的
```c++
class Solution {
public:
   int cal_sum(const vector<int>&stones){
        int left = 0;
        int right = stones.size()-1;
        int sum = 0;
        while(left < right){
            sum += stones[left] + stones[right];
            left++;
            right--;
        }
        if(left == right){
            sum += stones[left];
        }
        return sum;
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        int len = nums.size();
        int sum = cal_sum(nums);
        if((sum-target) %2 != 0 || sum-target < 0){return 0;}
        int neg = (sum-target) / 2;

        vector<vector<int>>dp(len,vector<int>(neg+1,0));
        if(nums[0] <= neg){
            dp[0][nums[0]] = 1;
        }
        dp[0][0] = nums[0] == 0 ? 2 : 1;
        for(int i=1;i<len;i++){
            for(int j=0;j<neg+1;j++){
                if( j >= nums[i]){
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]; 
                }
                else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[len-1][neg];
    }
};
```

## 474.一和零
dp[i][j][k] 在0-i的区间内 子集中最多有j个0和k个1的情况下子集最大长度
边界值:
dp[i][0][0]  = 0
dp[0][j][k]取决于str[0]
```c++
class Solution {
private:
    unordered_map<string,pair<int,int>>hash_str_zo;
public:
    void creat_hash(const vector<string>& strs){
        for(string str : strs){
            int zero = 0;
            for(char c : str){
                if(c == '0'){zero ++ ;}
            }
            hash_str_zo[str] = make_pair(zero,str.length() - zero);
        }
    }
    //dp[i][j][k] 在0-i的区间内 子集中最多有j个0和k个1的情况下子集最大长度
    int findMaxForm(vector<string>& strs, int m, int n) {
        creat_hash(strs);
        vector<vector<vector<int>>>dp(strs.size(),vector<vector<int>>(m+1,vector<int>(n+1,0)));
        //边界:
        /*
            dp[i][0][0]  = 0
            dp[0][j][k]取决于str[0]
        */
        for(int j=0;j<m+1;++j){
            for(int k=0;k<n+1;++k){
                if(j >= hash_str_zo[strs[0]].first && k >= hash_str_zo[strs[0]].second){
                    dp[0][j][k] = 1;
                }
            }
        }
        
        for(int i=1;i<strs.size();++i){
            for(int j=0;j<m+1;++j){
                for(int k = 0;k<n+1;++k){
                    dp[i][j][k] = dp[i-1][j][k];
                    if(  j>=hash_str_zo[strs[i]].first && k >= hash_str_zo[strs[i]].second    ){
                        dp[i][j][k] = max(dp[i][j][k] , dp[i-1][j - hash_str_zo[strs[i]].first][k-hash_str_zo[strs[i]].second] + 1);
                    }
                }
            }
        }
        return dp[strs.size()-1][m][n];
    }
};
```

## 完全背包问题 卡码网 52. 携带研究材料（第七期模拟笔试）
小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。

小明的行李箱所能承担的总重量为 N，问小明应该如何抉择，才能携带最大价值的研究材料，**每种研究材料可以选择无数次，并且可以重复选择。**

第一行包含两个整数，N，V，分别表示研究材料的种类和行李空间 
接下来包含 N 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值
输出一个整数，表示最大价值。

相比于0-1背包，首先由于元素可以重复，在对dp[0][j]初始化的时候，就需要**尽可能的充实空间**，而不是仅当j>=w 赋值为value[0]

在递推的过程中，
0-1背包的是:
dp[i][j] = max(dp[i][j] , dp[i-1][j-weight[i]] + value[i]);
完全背包是:
dp[i][j] = max(dp[i][j] , dp[i][j-weight[i]] + value[i]);


因为在0-1背包中，需要考虑的是第 i-1 个物品放入背包后的状态，即在背包容量为 j 的情况下，不考虑放入不放入第 i 个物品时的最优解。

因为在完全背包中，物品是无限次放入背包的，所以dp[i][j]
直接考虑背包放入的情况，考虑放入第 i 个物品后的最优解。


**背包初始化的方式决定了背包是完全的还是0-1**


```c++
#include<iostream>
#include<vector>

using namespace std;

int main(){
    int N,V;

    cin >> N;
    cin >> V;
    vector<int>weight(N);
    vector<int>value(N);
    for(int i=0;i<N;++i){
        cin >> weight[i];
        cin >> value[i];
    }
    
    vector<vector<int>>dp(N,vector<int>(V+1,0));
    for(int j = 0;j<= V ;++j){
        if(j >= weight[0]){
            dp[0][j] = dp[0][j-weight[0]] + value[0];
        }
    }
    
    
    for(int i=1;i<N;++i){
        for(int j=1;j<=V;++j){
            dp[i][j] = dp[i-1][j];
            if(j >= weight[i]){
                dp[i][j] = max(dp[i][j] , dp[i][j-weight[i]] + value[i]);
            }
        }
    }

    std::cout<< dp[N-1][V];
    return 0;
}
```

## 518.零钱兑换II -- 完全背包
相比零钱背包的爬楼梯问题，这里求解的是组合的结果 认为2+1 1+2是同一种结果，所以不能和零钱背包混为一谈
```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
       //dp[i][j] 使用0-i区间的硬币数量  凑成和为j 的方法数
       vector<vector<int>>dp(coins.size(),vector<int>(amount+1,0));
       //dp[i][0]
       for(int i=0;i<coins.size();++i){
           dp[i][0] = 1;
       }  
       //dp[0][j]
       for(int j=coins[0];j<amount+1;j+=coins[0]){
           dp[0][j] = 1 ;
       }

        for(int i=1;i<coins.size();++i){
            for(int j=1;j<amount+1;++j){
                dp[i][j] = dp[i-1][j];
                if(  j >= coins[i]   ){
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]];
                }
            }
        }
        return dp[coins.size()-1][amount];
    }
};
```




# ***背包问题的排列/组合问题？
<font color=red>
在背包问题中我们常见的就是组合问题(2+1和1+2是一种)或排列(1+2和2+1不是一种)问题。
有这么一个公式是这么说的:
如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。


其实组合问题是非常常见的，例如我们上面看到的0-1背包到完全背包其实都是组合问题，其特点是要么问可以装的最大数、能否装满背包(装的物品的价值的和是某一个target)，其实是问**能不能**的问题。所以都是先遍历物品(给的硬币数组、数组数据等等)在遍历背包

而对于排列问题，看似"外层for遍历背包，内层for循环遍历物品。"并不好理解，其实这就是一个**爬楼梯**问题，因为先爬一阶再爬两阶和先爬两阶再爬一阶是不一样的，在这个前提下我们可以将排列问题都转换为爬楼梯问题
</font>

# 139.单词拆分
dp[i] 长度为i的(0-i)的字符串能否被wordDict表达

dp[i]递推条件  i>= len 并且 此时i-s_len - i区间的子字符和查询字典的str相同 才会让dp[i]接受dp[i-s_len]的状况

```c++
i>=str && s.substr(i - str) == s_str
dp[i] = dp[i] | dp[i - s_len]  
```

```c++
class Solution {
public:
    string getstr(string s,int i,int len){
        return s.substr(i-len,len);
    }
    bool wordBreak(string s, vector<string>& wordDict) {
        int len = s.length();
        unordered_map<string,int>hash_table;
        for(string str:wordDict){
            hash_table[str] = str.length();
        }
        vector<bool>dp(len+1,false);
        dp[0] = true;
        //dp[i] 长度为i的(0-i)的字符串能否被wordDict表达
        for(int i=1;i<len+1;i++){
            for(auto &[s_str,s_len] : hash_table){
                if( i - s_len >= 0 && getstr(s,i,s_len) == s_str ){
                    dp[i] = dp[i] | dp[i-s_len];
                }
            }
        }
        // for(bool res : dp){
        //     std::cout<<res <<" ";
        // }
        // std::cout << std::endl;
        return dp[len];
    }
};
```
# 完全背包问题 -- 卡码网56

<font color = red>完全背包和01背包在二维dp上的区别理
在0-1背包问题的时候dp[i-1][j - weight[i]] + value[i] 是指选择第i件物品，将前i-1 物品 放入 容量为 j - weight[i] 背包的价值 再加上 第i件物品的价值。
在完全背包中此时 第i件已经放入了 ，故为 dp[i] [j - weight[i]] + value[i]。 因为01背包(每个物品都只选一次) ！！

dp[i][j - weight[i]] + value[i] 是指 第i件物品是可以重复存放的。</font>


题目描述:
你是一名宇航员，即将前往一个遥远的行星。在这个行星上，有许多不同类型的矿石资源，每种矿石都有不同的重要性和价值。你需要选择哪些矿石带回地球，但你的宇航舱有一定的容量限制。 
给定一个宇航舱，最大容量为 C。现在有 N 种不同类型的矿石，每种矿石有一个重量 w[i]，一个价值 v[i]，以及最多 k[i] 个可用。不同类型的矿石在地球上的市场价值不同。你需要计算如何在不超过宇航舱容量的情况下，最大化你所能获取的总价值。

输入共包括四行，第一行包含两个整数 C 和 N，分别表示宇航舱的容量和矿石的种类数量。 

接下来的三行，每行包含 N 个正整数。具体如下： 
第二行包含 N 个整数，表示 N 种矿石的重量。 
第三行包含 N 个整数，表示 N 种矿石的价格。 
第四行包含 N 个整数，表示 N 种矿石的可用数量上限。

在原先的基础上 在多加一个循环：判断当前向背包中放多少个


我们给出二维0-1背包的代码 
```c++
#include<iostream>
#include<vector>
 
using namespace std;
 
int main(){
    int C,N;
    cin >> C;
    cin >> N;
     
    vector<int>weight(N);
    vector<int>value(N);
    vector<int>times(N);
     
    for(int i=0;i<N;++i){
        cin >> weight[i];
    }
    for(int i=0;i<N;++i){
        cin >> value[i];
    }
    for(int i=0;i<N;++i){
        cin >> times[i];
    }
     
    vector<vector<int>>dp(N,vector<int>(C+1,0));
    //dp[i][0] = 0
    //dp[0][j] 
    
    for(int j=1;j<=C;++j){
        for(int k=1;k<=times[0];++k){
            if(j - k * weight[0] >= 0){
                dp[0][j] = max(k*value[0],dp[0][j]);
            }
        }
    }
    for(int i=1;i<N;++i){
        for(int j=1;j<=C;++j){
            dp[i][j] = dp[i-1][j];
            for(int k=1;k<=times[i]&& j - weight[i] * k >= 0;++k){
                    dp[i][j] = max(dp[i-1][j-k*weight[i]] + k* value[i],dp[i][j]);
                }
            }
    }
    std::cout << dp[N-1][C] <<std::endl;
    return 0;
}
```

## 进阶 我们给出一维背包问题的代码
注意 一维背包建立dp只建立了0-背包数量
但是遍历的时候还是二维遍历的方式

**最重要的区别 一维情况下背包大小是从大到小建立的，而不是从小到大**
如果从小到大就会导致重复遍历的问题，因为dp[i]是和dp[i-j]有关的，如果从小到大，先更新了dp[i-j]，在计算dp[i]的时候就会导致重复
在二维的角度上 就是dp[i][j]加dp[i][j-coins[i]](变成多重背包问题，引入重复)
同时在这个角度上也就说明了为什么多重背包是加dp[i][j-coins[i]]


```c++
#include<iostream>
#include<vector>

using namespace std;

int main(){
    int C,N;
    cin >> C;
    cin >> N;
    
    vector<int>weight(N);
    vector<int>value(N);
    vector<int>times(N);
    
    for(int i=0;i<N;++i){
        cin >> weight[i];
    }
    for(int i=0;i<N;++i){
        cin >> value[i];
    }
    for(int i=0;i<N;++i){
        cin >> times[i];
    }
    
    vector<int>dp(C+1,0);


    for(int i=0;i<N;++i){
        for(int j=C;j>=1;--j){
            for(int k=1;k<=times[i] && j - weight[i] * k >= 0;++k){
                dp[j] = max(dp[j-k*weight[i]] + k* value[i],dp[j]);
            }
        }
    }
    std::cout << dp[C] <<std::endl;
    return 0;
}
```

# 198.打家劫舍1
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int len = nums.size();
        vector<int>dp(len,0);
        dp[0] = nums[0];
        if(len == 1){return dp[0];}
        dp[1] = max(nums[0],nums[1]);
        for(int i=2;i<len;++i){
            dp[i] = max(dp[i-1] , dp[i-2] + nums[i]);
        }
        return dp[len-1];
    }
};
```
# 213.打家劫舍II
思路 将环拆开 从0-len-1 和从 1-len两个组合
```c++
class Solution {
public:
    int rob_01(vector<int>& nums,int start,int end) {
        int len = end - start;
        vector<int>dp(len,0);
        dp[0] = nums[start];
        if(len == 1){return dp[0];}
        dp[1] = max(nums[start],nums[start+1]);
        for(int i=2;i<len;++i){
            dp[i] = max(dp[i-1] , dp[i-2] + nums[i+start]);
        }
        return dp[len-1];
    }
    int rob(vector<int>& nums) {
        int len = nums.size();
        if(len == 1) {return nums[0];}
        return max(rob_01(nums,0,len-1),rob_01(nums,1,len));
    }
};
```
# 337.打家劫舍 III
1.如何遍历:  首先排除层序遍历 因为最终的结果不一定只出现在同一层。当前结点有没有遍历，是取决于儿子节点有没有被选取 -- 这样这个题就很想贪心篇的监控二叉树的题目，需要自底向上的遍历，所以选择后续遍历
2.如何使用dp呢，我们定义迭代值为Vector<int>dp(2,0),其中dp[0]表示当前结点偷，dp[1]表示不用当前节点不偷。
如果当前节点偷，那么子节点一定不偷，当前节点的dp[0] = 左子叶不偷 + 右子叶不偷 + 当前节点的val
如果当前节点不偷，此时左右子节点可以偷也可以不偷，所以dp[1] = 左子叶偷或者不偷的最大值 + 右子叶偷或者不偷的最大值

```c++
class Solution {
public:
    vector<int> back_Travel(TreeNode* root){
        if(root == nullptr){
            return {0,0};
        }
        vector<int>left = back_Travel(root->left);
        vector<int>right = back_Travel(root->right);
        vector<int>ans_cur(2,0);
        //偷当前节点  当前结点val + 左右子节点不偷的结果
        ans_cur[0] = left[1] + right[1] + root->val;
        //不偷当前结点 左右子节点偷 这里左右子节点可以偷也可以不偷
        ans_cur[1] = max(left[0],left[1]) + max(right[0],right[1]);
        return ans_cur;
    }
    int rob(TreeNode* root) {
        vector<int>res(2,0);
        res = back_Travel(root);
        return max(res[0],res[1]);
    }
};
```

# 121 买卖股票的最佳时机1
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_price = prices[0];
        int max_profit = 0;
        for(int i=1;i<prices.size();++i){
            if(prices[i] > min_price){
                max_profit = max(max_profit,prices[i] - min_price);
            }
            else{
                min_price = prices[i];
            }
        }
        return max_profit;
    }
};
```
# 122.买卖股票的最佳时机II
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        //dp[i][0] 第i天不持有当前股票的最大利益
        //dp[i][1] 第i天持有当前股票的最大利益
        int len = prices.size();
        vector<vector<int>>dp(len,vector<int>(2,0));
        dp[0][1] = -prices[0];
        for(int i=1;i<len;++i){
            dp[i][0] = max(dp[i-1][0] , dp[i-1][1] + prices[i]);
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i]);
        }
        //return max(dp[len-1][0],dp[len-1][1]);
        return dp[len-1][0];
    }
};
```
# 123.买卖股票的最佳时机III
由于允许有两次买卖，那么dp的状态有以下五种:
0.没有持有股票  -- 没有任何操作
1.第一次持有股票
2.第一次没有持有股票
3.第二次持有股票
4.第二次没有持有股票


这里为什么在初始化的时候dp[0][3]也要赋值？ 可以理解为在第0天 买入立即卖出 然后再买入，构成第二次持有股票的情况

返回值问题:此时返回值一定是不持有股票的状态
现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。如果想不明白的录友也可以这么理解：如果第一次卖出已经是最大值了，那么我们可以在当天立刻买入再立刻卖出。所以dp[4][4]已经包含了dp[4][2]的情况。也就是说第二次卖出手里所剩的钱一定是最多的。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>>dp(len,vector<int>(5,0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for(int i=1;i<len;i++){
            dp[i][0] = dp[i-1][0];
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i]);
            dp[i][2] = max(dp[i-1][2],dp[i-1][1] + prices[i]);
            dp[i][3] = max(dp[i-1][3],dp[i-1][2] - prices[i]);
            dp[i][4] = max(dp[i-1][4],dp[i-1][3] + prices[i]);
        }
        return dp[len-1][4];
    }
};
```

# 188.买卖股票的最佳时机IV  -- 购买股票最佳时机母题
可以看做是123题的泛化
```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>>dp(len,vector<int>(2*k+1,0));
        for(int i=1;i<2*k+1;i+=2){
            dp[0][i] = -prices[0];
        }
        for(int i=1;i<len;++i){
            dp[i][0] = dp[i-1][0];
            for(int j=1;j<2*k+1;++j){
                if(j%2==0){
                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1] + prices[i]);
                }else{
                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1] - prices[i]);
                }
            }
        }
        return dp[len-1][2*k];
    } 
};
```
在这个代码的情况下，我们额外基于优化:将dp转化为一维
```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int len = prices.size();
        vector<int>dp(2*k+1,0);
        for(int i=1;i<2*k+1;i+=2){
            dp[i] = -prices[0];
        }
        for(int i=1;i<len;++i){
            dp[0] = dp[0];
            for(int j=1;j<2*k+1;++j){
                if(j%2==0){
                    dp[j] = max(dp[j],dp[j-1] + prices[i]);
                }else{
                    dp[j] = max(dp[j],dp[j-1] - prices[i]);
                }
            }
        }
        return dp[2*k];
    } 
};
```
事实上 由于这个题目可以转化为一维，那么购买股票的最佳时机2/3都可以写成一维dp。

为什么可以这么写:
dp[1] = max(dp[1], dp[0] - prices[i]); 如果dp[1]取dp[1]，即保持买入股票的状态，那么 dp[2] = max(dp[2], dp[1] + prices[i]);中dp[1] + prices[i] 就是今天卖出。这一步相当于在二维的时候，dp[i][1] = dp[i-1][1] 

如果dp[1]取dp[0] - prices[i]，今天买入股票，那么dp[2] = max(dp[2], dp[1] + prices[i]);中的dp[1] + prices[i]相当于是今天再卖出股票，一买一卖收益为0，对所得现金没有影响。相当于今天买入股票又卖出股票，等于没有操作，保持昨天卖出股票的状态了。这一步相当于在二维的时候，dp[i][1] = dp[i-1][0] - price[0]  dp[2]在这一轮要么保持(不卖出dp[i-1][2])，要么就卖出(dp[i-1]+price[i]) ，但是此时相当于当天买入当天卖出

所以虽然在二维中dp[i][j] 受dp[i-1][*]影响 其实在一维中可以看做是收到dp[i-]（上一轮循环）的影响。
**<font color=red>这也是股票问题最核心的问题 dp表示的是股票的持有或不持有状态，并不是代表在当天买/卖出股票</font>**
```c++
//购买股票的最佳时机2
class Solution {df
public:
    int maxProfit(vector<int>& prices) {
        //dp[i][0] 第i天不持有当前股票的最大利益
        //dp[i][1] 第i天持有当前股票的最大利益
        int len = prices.size();
        vector<int>dp(2,0);
        dp[1] = -prices[0];
        for(int i=1;i<len;++i){
            dp[0] = max(dp[0],dp[1] + prices[i]);
            dp[1] = max(dp[1],dp[0] - prices[i]);
        }
        // return max(dp[len-1][0],dp[len-1][1]);
        return dp[0];
    }
};
//购买股票的最佳时机3
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<int>dp(5,0);
        dp[1] = -prices[0];
        dp[3] = -prices[0];
        for(int i=1;i<len;i++){
            dp[0] = dp[0];
            dp[1] = max(dp[1],dp[0] - prices[i]);
            dp[2] = max(dp[2],dp[1] + prices[i]);
            dp[3] = max(dp[3],dp[2] - prices[i]);
            dp[4] = max(dp[4],dp[3] + prices[i]);
        }
        return dp[4];
    }
};
```

# ***309.最佳买卖股票时机含冷冻期
含有冷冻期，将持有和不持有状态影响:
第i天不持有股票   有以下可能 1.从前一天持有股票的状态卖出  2.前一天就不持有股票  3.前一天是卖出了股票导致当前是冷冻期
第i天持有股票     要么是前一天就持有股票 要么是**从可以买股票的不持有股票状态购买  对应了上述的2、3，所以可以将上述的2、3合成一个情况，或者前一天是冷冻期**
第i天是冷冻状态，只能从不持有股票的状态1获取
```c++
/*
dp[0] --  持有股票  -- 从前一天冷冻期 或dp[1]中   购买
dp[1] --  不持有股票 前一天是冷冻期  前一天没有持有股票 此时可以买入
dp[2]  -- 不持有股票 前一天持有股票抛售出股票 今天进入冷冻期 此时不能买入
dp[3]  -- 冷冻期 -- 前一天dp[2]进来;
*/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>>dp(len,vector<int>(4,0));
        dp[0][0] = -prices[0];
        for(int i=1;i<len;++i){
            dp[i][0] = max(dp[i-1][0],max(dp[i-1][1]-prices[i],dp[i-1][3]-prices[i]));
            dp[i][1] = max(dp[i-1][1],dp[i-1][3]);
            dp[i][2] = dp[i-1][0] + prices[i];
            dp[i][3] = dp[i-1][2];
        }
        return max(dp[len-1][1],max(dp[len-1][2],dp[len-1][3]));
    }
};
```
# 714.买卖股票的最佳时机含手续费
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<vector<int>>dp(prices.size(),vector<int>(2,0));
        dp[0][0] = -prices[0];
        for(int i=1;i<prices.size();++i){
            dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i] - fee);
        }
        return dp[prices.size()-1][1];
    }
};
```

# 300.最长递增子序列
这属于不连续子集问题，在这个问题下dp[i] 是和之前所有的dp[j]相关的，所以虽然是一维的dp，但是会出现两个循环

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int len = nums.size();
        if(len == 0){return 0;}
        vector<int>dp(len,0);
        dp[0] = 1;
        int result = 0;
        for(int i=0;i<len;++i){
            //每一个元素i都可以单独作为一个变量
            dp[i] = 1;
            for(int j=0;j<i;++j){
                if(nums[i] > nums[j]){
                    dp[i] = max(dp[i],dp[j]+1);
                }
            }
            result = max(result,dp[i]);
        }
        return result;
    }
};
```
Q:这里为什么不能返回dp[len-1]，而是还需要一个值记录最大值
A:因为这里dp[i]的含义是包含第i个元素在内，从0-i的最大子序列长度，最长的子序列不一定是包含nums[len-1]


## 延伸 : 1027. 最长等差数列
注意这里dp的逻辑 这里需要记录当前最长的等差数列的长度和公差
```c++
class Solution {
public:
    //题中限制公差范围 -500 - 500 我们处理成 0 - 1000
    //dp[i][j] 表示以nums[i]结尾 公差为j的等差子序列长度
    int longestArithSeqLength(vector<int>& nums) {
        int len = nums.size();
        //初始化 1 表示每一个单独的元素就是一个长度为1的等差数列
        vector<vector<int>>dp(len,vector<int>(1001,1));
        int ans = 0;
        for(int i=1;i<len;++i){
            for(int k=0;k<i;++k){
                int j = nums[i] - nums[k] + 500;
                dp[i][j] = max(dp[i][j],dp[k][j] + 1);
                ans = max(ans,dp[i][j]);
            }
        }
        return ans;
    }
};
```



# 674. 最长连续递增序列
连续问题 dp[i]的状态之和dp[i-1]相关，所以只会有一个循环
**连续问题在dp中体现一个迭代，如果当前满足就继续，如果不满足就从头开始，而不是从前文中最大的位置开始**
```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int len = nums.size();
        vector<int>dp(len);
        dp[0] = 1;
        if(len == 1){return dp[0];}
        int max_len = 1;
        for(int i=1;i<len;++i){
            if(nums[i] > nums[i-1]){
                dp[i] = dp[i-1] + 1;
            }
            else{
                dp[i] = 1;
            }
            max_len = max(max_len,dp[i]);
        }
        return max_len;
    }
};
```

# 718. 最长重复子数组
dp[i][j]表示数组A 0-i区间 和数组B 0-j区间的重复子数组长度  -- 因为是连续 所以之和i-1，j-1有关系
```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int len1 = nums1.size();
        int len2 = nums2.size();
        vector<vector<int>>dp(len1,vector<int>(len2,0));
        int max_len = 0;
        for(int i=0;i<len1;++i){
            if(nums1[i] == nums2[0]){
                dp[i][0] = 1;
                max_len = 1;
            }
        }
        for(int i=0;i<len2;++i){
            if(nums2[i] == nums1[0]){
                dp[0][i] = 1;
                max_len = 1;
            }
        }
        for(int i=1;i<len1;++i){
            for(int j=1;j<len2;++j){
                if(nums1[i] == nums2[j]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                max_len = max(dp[i][j],max_len);
            }
        }

        return max_len;
    }
};
```
# 1143.最长公共子序列
```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int len1 = text1.size();
        int len2 = text2.size();
        vector<vector<int>>dp(len1,vector<int>(len2,0));
        int max_len = 0;
        for(int i=0;i<len1;++i){
            if(text1[i] == text2[0] || (i >0 && dp[i-1][0] == 1)){
                dp[i][0] = 1;
                max_len = 1;
            }
        }
        for(int i=0;i<len2;++i){
            if(text2[i] == text1[0] || (i >0 && dp[0][i-1] == 1)){
                dp[0][i] = 1;
                max_len = 1;
            }
        }

        for(int i=1;i<len1;++i){
            for(int j=1;j<len2;++j){
                if(text1[i] == text2[j]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[len1-1][len2-1];
    }
};
```


注意这两个题目之间的区别:
718. 最长重复子数组 中 dp[i][j]可以理解为 包含A 0-i B 0-j 从A的某个结点出发到A[i] 和从B的某个结点出发到B[j] 连续的公共序列长度是多少  一定要包含A[i] B[j]，也即一定要比较末尾是否匹配，在初始化的时候,只有当末尾字符i==0 才会将其赋值为1 而最大长度不一定以i、j结尾 所以设置最大长度.
1143.最长公共子序列 中dp[i][j]可以理解为 包含A 0-i B 0-j 从A的某个结点出发到A[i] 和从B的某个结点出发到B[j] 中最大不连续公共序列长度，即包含就有，所以在初始化的时候就只要前面出现过text[0] 就会赋值为1  而当末尾匹配不到的时候，也不会赋值为0

718和1143的dp都表示包含第i、j位置元素时候的dp值，但是718中最长重复子数组不一定含有i、j元素。而1143中包含i、j的递推关系可以由dp[i-1][j],dp[i][j-1]中最大的推出 那么dp[len1-1][len2-1]一定是满足的(如果不理解就也用max记录就好了)


# 1035.不想交的线
```c++
class Solution {
public:
    //查找字符之间最大的公共字符串数量
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int len1 = nums1.size();
        int len2 = nums2.size();
        vector<vector<int>>dp(len1,vector<int>(len2,0));
        for(int i=0;i<len1;++i){
            if(nums1[i] == nums2[0] ||(i>0 && dp[i-1][0] != 0)){
                dp[i][0] = 1;
            }
        }
        
        for(int j=0;j<len2;++j){
            if(nums2[j] == nums1[0] ||(j>0 && dp[0][j-1] != 0)){
                dp[0][j] = 1;
            }
        }
        if(len1 == 1){return dp[0][len2-1];}
        if(len2 == 1){return dp[len1-1][0];}
        for(int i=1;i<len1;++i){
            for(int j=1;j<len2;++j){
                if(nums1[i] == nums2[j]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else{
                    dp[i][j] = max(dp[i][j-1],dp[i-1][j]);
                }
            }
        }
        return dp[len1-1][len2-1];
    }
};
```
# 53. 最大子序和
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int len = nums.size();
        vector<int>dp(len,0);
        dp[0] = nums[0];
        int max_ans = dp[0];
        for(int i=1;i<len;++i){
            dp[i] = max(dp[i-1]+nums[i],nums[i]);
            max_ans = max(max_ans,dp[i]);
        }
        return max_ans;
    }
};
```

# 392.判断子序列
方法一:直接查找
```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int _len_t = t.size();
        int _len_s = s.size();
        if(_len_s == 0 && _len_t == 0){return true;}
        int cur_id = 0;
        for(int i=0;i<_len_t;++i){
            if(t[i] == s[cur_id]){
                ++cur_id;
            }
            if(cur_id == _len_s){
                return true;
            }
        }
        return false;
    }
};
```

## 进阶 918. 环形子数组的最大和
```c++
class Solution {
public:
    //单调队列维护展开环数组的前缀和
    int maxSubarraySumCircular(vector<int>& nums) {
        int len=nums.size();
        deque<pair<int,int>>q;
        int pre_sum = nums[0];
        int res = nums[0];
        q.push_back(make_pair(0,pre_sum));
        for(int i=1;i<len*2;++i){
            while(!q.empty() && q.front().first < i-len){
                q.pop_front();
            }
            pre_sum += nums[i%len];
            res = max(res,pre_sum-q.front().second);
            while(!q.empty() && q.back().second >= pre_sum){
                q.pop_back();
            }
            q.push_back(make_pair(i,pre_sum));
        }
        return res;
    }
};
```


# 115.不同的子序列
dp[i][j]  s以第i个元素结尾 t以第j个元素结尾 t是s子序列的方法

初始化:
dp[0][j] 长度为 0的s子串不能 不能表示长度大于他的t子串
dp[i][0] 长度为i的子串 在子串中有几个t[0]就表示能有几种表示方法

递推
dp[i][j]  如果t[j] == s[i] 说明当前可以由dp[i-1][j-1]表达  也可以由dp[i-1][j]表达
如果不等于 就只能由dp[i-1][j]表达

```c++
class Solution {
private:
    const int mod= 1e9 + 7;
public:
    int numDistinct(string s, string t) {
        int len_s = s.size();
        int len_t = t.size();
        //dp[i][j]  s以第i个元素结尾 t以第j个元素结尾 t是s子序列的方法
        vector<vector<int>>dp(len_s,vector<int>(len_t,0));
        if(t[0] == s[0]){dp[0][0] = 1;}
        for(int i=1;i<len_s;++i){
            dp[i][0] = dp[i-1][0];
            if(s[i] == t[0]){
                dp[i][0] ++;
            }
        }

        for(int i=1;i<len_s;++i){
            for(int j=1;j<len_t;++j){
                if(t[j] == s[i]){
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                }
                else{
                    dp[i][j] = dp[i-1][j];
                }
                dp[i][j] = dp[i][j] % mod;
            }
        }
        return dp[len_s-1][len_t-1];
    }
};
```

# 583. 两个字符串的删除操作
把问题转换为计算两个字符串的最长公共子序列
```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len_1 = word1.size();
        int len_2 = word2.size();
        
        
        vector<vector<int>>dp(len_1,vector<int>(len_2,0));
        for(int i=0;i<len_1;++i){
            if(word1[i] == word2[0] || (i>0 && dp[i-1][0] !=0)){
                dp[i][0] = 1;
            }
        }
        for(int j=0;j<len_2;++j){
            if(word2[j] == word1[0] || (j>0 && dp[0][j-1]!=0)){
                dp[0][j] = 1;
            }
        }

        for(int i=1;i<len_1;++i){
            for(int j=1;j<len_2;++j){
                if(word1[i] == word2[j]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);
                }
            }
        }

        return len_1 + len_2 - dp[len_1-1][len_2-1] * 2;
    }
};
```

# 72. *** 编辑距离
关于本题:
1.为什么dp扩充了一圈维度   -- 方便初始化，不这样的话 需要考虑用0-i长度字符串表达长度为0字符
我们给出如果dp不扩充维度,在初始化的时候 表示就需要考虑当前字节是否一致，就相当于要模拟第一轮推导的逻辑
**<font color=red>事实上 在dp的时候 如果发现初始化不好处理，往往是因为把初始化和第一轮推导放到一起了 就尝试对dp扩充维度</font>**

2.如何理解递推关系？
如果当前的i==j  那么自然就是从i-1,j-1递归出来
如果不相等呢   就是从插入 删除 替换演化而来
首先明确一下dp的定义  dp[i][j]表示从0-i 表示 0-j 字符的最小操作次数

如果dp[i][j]是从
1. dp[i-1][j-1]演化  就是替换  例如hors 表示 hora   就是将s变化为a 
2. dp[i][j-1] 演化 就是删除  例如 horsa 表示 hors 将a删除
3. dp[i-1][j] 演化 就是添加  例如 hors 表示 horsa 就是添加a

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.size();
        int len2 = word2.size();

        //dp[i][j]   word1(0-i) 变化到 word2(0,j)的最小操作次数
        //将dp扩充一圈 方便初始化
        vector<vector<int>>dp(len1+1,vector<int>(len2+1,0));
        dp[0][0] =0;
        for(int i=1;i<=len1;++i){
            dp[i][0] = i;
        }
        for(int j=1;j<=len2;++j){
            dp[0][j] = j;
        }
        for(int i=1;i<=len1;++i){
            for(int j=1;j<=len2;++j){
                if(word1[i-1] == word2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }
                else{
                    dp[i][j] =min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1])) + 1;
                }
            }
        }
        return dp[len1][len2];
    }
};
```
# 647. 回文子串
dp[i][j]  从 i-j 字符串是否是回文

注意遍历的顺序，先从i = len-1开始  然后j从i+1开始 (初始化的时候已经初始化了j==i的情况)

递推  需要考虑如果字符串长度只有2 这时就只需要判断s[i] == s[j] 如果相等就直接为true
如果字符串长度大于2 这时 s[i] == s[j]  的条件下 还取决于 i+1 - j-1是否是回文的

```c++
class Solution {
public:
    int countSubstrings(string s) {
        int len = s.length();
        vector<vector<bool>>dp(len,vector<bool>(len,false));
        int ans = 0;
        for(int i=0;i<len;++i){
            dp[i][i] = true;
            ++ans;
        }
        //dp[i][j]  从 i-j 字符串是否是回文
        for(int i=len-2;i>=0;--i){
            for(int j=i+1;j<len;++j){
                if(s[i] == s[j]){
                    if( j-i <= 1 ){
                        dp[i][j] = true;
                        ++ans;
                    }
                    else if(dp[i+1][j-1]){
                        dp[i][j] = dp[i+1][j-1];
                        ++ans;
                    }
                }
            }
        }
        return ans;
    }
};
```
# 516.最长回文子序列
dp[i][j]  i-j最长回文子序列长度

由于出现不回文的情况是允许删除的
当出现不回文的情况下，就要考虑删除 
dp[i][j] = max(dp[i+1][j],dp[i][j-1]);
为什么dp[i+1][j],dp[i][j-1]是删除呢  参考编辑距离一题中，这里就是保证i+1-j然后删除i   或者保证i-j-1 然后删除j
```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int len = s.length();
        vector<vector<int>>dp(len,vector<int>(len,0));
        for(int i=0;i<len;++i){
            dp[i][i] = 1;
        }
        for(int i=len-2;i>=0;--i){
            for(int j=i+1;j<len;++j){
                if(s[i] == s[j]){
                    if( j - i <= 1){
                        dp[i][j] = 2;
                    }
                    else{
                        dp[i][j] = dp[i+1][j-1] + 2;
                    }
                }
                else{
                    dp[i][j] = max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        return dp[0][len-1];
    }
};
```